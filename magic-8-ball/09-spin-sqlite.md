# Spin the Wheel for a Chance to Win: SQLite Storage from Spin Apps

Thank you for participating in the workshop! As a thanks, we'd like to present one lucky winner with
a real Magic 8 ball. But first, let's build a Spin app that will help us choose the winner.

Our app will take in contestant names and store them in a SQL database. Then, at any point, a winner
can be drawn, causing Spin to choose a random person from the database. To help make all this
happen, Spin provides an [interface](https://developer.fermyon.com/spin/sqlite-api-guide) for
persisting data to a local SQLite database.

## Creating a database schema

Let's first define our database schema in a migration file. Our database is very simple. It contains
one table called `contestants` with rows of names. We will be able to apply this migration to either
a local or deployed Spin up via a `spin up --sqlite` or `spin cloud sqlite execute`. Add the
following to a `migration.sql` file.

```sql
CREATE TABLE IF NOT EXISTS contestants (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL
);
```

## a. Building your a lottery Spin application with Rust

We will create a Spin application in Rust based on the HTTP template. Let's name the application and
our first component `lottery`. We will listen for requests at multiple paths, so we  can keep the
default root base and path of the component URL.

```bash
$ spin new http-rust lottery
Description: Spin the Wheel!
HTTP base: /
HTTP path: /
$ cd lottery
```

We can now start to fill in our HTTP component in our `lib.rs` file. First. let's add a user to the
database when a name is posted to the endpoint `/enter`:

```rs
use anyhow::Result;
use spin_sdk::{
    http::{Request, Response, Router, Params},
    http_component,
    sqlite::{Connection, ValueParam},
};

#[http_component]
fn handle_lottery(req: Request) -> Result<Response> {
    let mut router = Router::new();
    router.post("/enter", add_candidate);
    router.handle(req)
}

pub fn add_candidate(req: Request, _params: Params) -> Result<Response> {
    let body = req.body().as_deref().unwrap_or_default();
    let name = std::str::from_utf8(body)?;
    let connection = Connection::open_default()?;
    let execute_params = [ValueParam::Text(name)];
    connection.execute(
        "INSERT INTO contestants (name) VALUES (?)",
        execute_params.as_slice(),
    )?;
    Ok(http::Response::builder()
        .status(200)
        .header("foo", "bar")
        .body(Some(format!("Entered {name}").into()))?)
}
```

We are using the Spin Rust SDK's `http::Router` to more easily delegate requests to functions. Let's
now draw a random winner from our database if the `/winner` endpoint receives a request. First, add
another route to the router:

```rs
#[http_component]
fn handle_lottery(req: Request) -> Result<Response> {
    let mut router = Router::new();
    router.post("/enter", add_candidate);
    router.get("/winner", get_winner);
    router.handle(req)
}
```

Next, implement the `get_winner` function which will randomly select a candidate:

```rs
pub fn get_winner(_req: Request, _params: Params) -> Result<Response> {
    let connection = Connection::open_default()?;
    let result = connection.execute(
        "SELECT name
        FROM contestants
        ORDER BY RANDOM()
        LIMIT 1", &[]
    )?;
    let rows: Vec<_> = result.rows().collect();
    let winner = rows.first().unwrap().get::<&str>("name").unwrap().to_owned();
    Ok(http::Response::builder()
        .status(200)
        .header("foo", "bar")
        .body(Some(winner.into()))?)
}
```

Finally, for good measure, handle any other routes by replying with how to properly use the lottery:

```rs
#[http_component]
fn handle_lottery(req: Request) -> Result<Response> {
    let mut router = Router::new();
    router.post("/enter", add_candidate);
    router.get("/winner", get_winner);
    router.any("/*", wildcard);
    router.handle(req)
}
```

Simply inform the user of how to use each endpoint of the app:

```rs
fn wildcard(_req: Request, _params: Params) -> Result<Response> {
    Ok(http::Response::builder()
        .status(http::StatusCode::OK)
        .body(Some(
            "Please use /enter endpoint to join lottery and /winner endpoint to draw a winner"
                .to_string().into(),
        ))?)
}
```

Now build the application and configure the database.
```bash
spin build --up --sqlite="@migration.sql"
```

Enter the lottery:

```bash
curl -d "Enrico Fermi" -X POST http://127.0.0.1:3000/enter
```

Draw the winner:

```bash
curl http://127.0.0.1:3000/winner
```

Fermyon Cloud also supports [NoOps SQL databases](https://developer.fermyon.com/cloud/noops-sql-db).
You can persist relational data generated by your Spin application in between application
invocations without worrying about database management. After [signing up for the private beta of
the feature](https://developer.fermyon.com/cloud/noops-sql-db#accessing-private-beta) and getting a
confirmation, you can deploy your local app to the cloud:

> Note: Users are limited to one NoOps SQL DB in Fermyon Cloud

```bash
spin deploy
```

List you current databases and see that one has been made for you:

```bash
$ spin cloud sqlite list
Databases (1)
charming-tangerine (default)
```

Let's update the schema of this database:

```bash
spin cloud sqlite execute charming-tangerine "@migration.sql"
```

Now, anyone can join your lottery!

### Learning Summary

In this section you learned how to:

- [x] Persist relational data using Spin's default SQLite store using the Spin SQLite API

### Navigation

- Go back to [08- Running Spin on Kubernetes](08-kubernetes.md) if you still have questions on previous section
- Otherwise, congrats on finishing the workshop! 
- (_optionally_) Let us know what you thought of the Spin and the workshop with this [short Typeform survey](https://fibsu0jcu2g.typeform.com/to/RK08OLSy#hubspot_utk=xxxxx&hubspot_page_name=xxxxx&hubspot_page_url=xxxxx).